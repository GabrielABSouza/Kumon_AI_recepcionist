"""
Template Variable System with Stage-Aware Data Collection

Intelligent variable resolution system that:
- Maps conversation stages to required data
- Collects data from CeciliaState.collected_data
- Applies intelligent fallbacks for missing data
- Integrates gender detection when appropriate
"""

from typing import Dict, Any, Optional, Set
from enum import Enum

from ..core.state.models import ConversationStage, ConversationStep
from ..utils.gender_detector import gender_detector
from ..core.logger import app_logger


class VariableType(Enum):
    """Types of template variables"""
    REQUIRED = "required"        # Must be available, use fallback if missing
    OPTIONAL = "optional"        # Use if available, skip if missing
    GENERATED = "generated"      # Generated by system (gender, timestamps)


class StageDataMapper:
    """Maps conversation stages to expected data and variables"""
    
    def __init__(self):
        # Define what data is expected at each stage
        self.stage_data_mapping = {
            ConversationStage.GREETING: {
                "available_data": ["parent_name", "child_name", "is_for_self"],
                "required_variables": {"parent_name", "username"},
                "optional_variables": {"child_name", "student_name"},
                "generated_variables": {"gender_self_suffix", "gender_pronoun"}
            },
            
            ConversationStage.QUALIFICATION: {
                "available_data": ["parent_name", "child_name", "is_for_self", "student_age", "education_level"],
                "required_variables": {"parent_name", "child_name", "student_name"},
                "optional_variables": {"student_age", "education_level"},
                "generated_variables": {"gender_pronoun", "gender_article", "gender_child_term"}
            },
            
            ConversationStage.INFORMATION_GATHERING: {
                "available_data": ["parent_name", "child_name", "student_age", "programs_of_interest"],
                "required_variables": {"parent_name", "student_name"},
                "optional_variables": {"student_age", "programs_of_interest"},
                "generated_variables": {"gender_pronoun", "gender_possessive"}
            },
            
            ConversationStage.SCHEDULING: {
                "available_data": ["parent_name", "child_name", "date_preferences", "available_slots", "selected_slot"],
                "required_variables": {"parent_name", "student_name"},
                "optional_variables": {"selected_slot", "date_preferences"},
                "generated_variables": {"gender_pronoun"}
            },
            
            ConversationStage.CONFIRMATION: {
                "available_data": ["parent_name", "child_name", "selected_slot", "contact_email"],
                "required_variables": {"parent_name", "student_name", "contact_email"},
                "optional_variables": {"selected_slot"},
                "generated_variables": {"gender_pronoun"}
            }
        }
        
        # Fallback values for missing required data
        self.fallbacks = {
            "parent_name": "responsável",
            "username": "responsável", 
            "child_name": "seu(a) filho(a)",
            "student_name": "seu(a) filho(a)",
            "student_age": "criança",
            "contact_email": "seu email"
        }


class TemplateVariableResolver:
    """Resolves template variables intelligently based on conversation state"""
    
    def __init__(self):
        self.mapper = StageDataMapper()
    
    def get_template_variables(
        self,
        conversation_state: Dict[str, Any],
        user_variables: Optional[Dict[str, Any]] = None,
        stage_override: Optional[ConversationStage] = None
    ) -> Dict[str, str]:
        """
        Get all template variables for current conversation state
        
        Args:
            conversation_state: Current CeciliaState
            user_variables: Additional variables provided by caller
            stage_override: Override stage detection (for testing)
            
        Returns:
            Complete variable dictionary ready for template formatting
        """
        try:
            # Determine current stage
            current_stage = stage_override or conversation_state.get("current_stage", ConversationStage.GREETING)
            collected_data = conversation_state.get("collected_data", {})
            
            app_logger.info(f"Resolving variables for stage: {current_stage}")
            
            # Get stage mapping
            stage_config = self.mapper.stage_data_mapping.get(current_stage, {})
            required_vars = stage_config.get("required_variables", set())
            optional_vars = stage_config.get("optional_variables", set())
            generated_vars = stage_config.get("generated_variables", set())
            
            variables = {}
            
            # 1. Process required variables with intelligent fallbacks
            for var_name in required_vars:
                variables[var_name] = self._resolve_required_variable(
                    var_name, collected_data, user_variables
                )
            
            # 2. Process optional variables (only if available)
            for var_name in optional_vars:
                value = self._resolve_optional_variable(
                    var_name, collected_data, user_variables
                )
                if value is not None:
                    variables[var_name] = value
            
            # 3. Generate dynamic variables (gender, timestamps, etc.)
            generated = self._generate_dynamic_variables(
                generated_vars, conversation_state, collected_data
            )
            variables.update(generated)
            
            # 4. Add user-provided variables (override everything)
            if user_variables:
                variables.update(user_variables)
            
            app_logger.info(f"Resolved {len(variables)} variables: {list(variables.keys())}")
            return variables
            
        except Exception as e:
            app_logger.error(f"Error resolving template variables: {e}")
            return user_variables or {}
    
    def _resolve_required_variable(
        self, 
        var_name: str, 
        collected_data: Dict[str, Any], 
        user_variables: Optional[Dict[str, Any]]
    ) -> str:
        """Resolve required variable with intelligent fallback"""
        
        # Priority 1: User-provided variables
        if user_variables and var_name in user_variables:
            return str(user_variables[var_name])
        
        # Priority 2: Collected data with exact match
        if var_name in collected_data:
            value = collected_data[var_name]
            if value:
                return str(value)
        
        # Priority 3: Smart mapping from collected data
        value = self._smart_data_mapping(var_name, collected_data)
        if value:
            return str(value)
        
        # Priority 4: Intelligent fallback
        fallback = self.mapper.fallbacks.get(var_name, f"[{var_name}]")
        app_logger.warning(f"Using fallback for required variable '{var_name}': {fallback}")
        return fallback
    
    def _resolve_optional_variable(
        self, 
        var_name: str, 
        collected_data: Dict[str, Any], 
        user_variables: Optional[Dict[str, Any]]
    ) -> Optional[str]:
        """Resolve optional variable, return None if not available"""
        
        # Priority 1: User-provided variables
        if user_variables and var_name in user_variables:
            return str(user_variables[var_name])
        
        # Priority 2: Direct mapping from collected data
        if var_name in collected_data:
            value = collected_data[var_name]
            if value:
                return str(value)
        
        # Priority 3: Smart mapping
        value = self._smart_data_mapping(var_name, collected_data)
        if value:
            return str(value)
        
        # Return None for missing optional variables
        return None
    
    def _smart_data_mapping(self, var_name: str, collected_data: Dict[str, Any]) -> Optional[str]:
        """Intelligent mapping between variable names and collected data"""
        
        mappings = {
            # Name mappings
            "username": ["parent_name", "child_name"],
            "student_name": ["child_name", "parent_name"],
            "parent_name": ["parent_name"],
            "child_name": ["child_name"],
            
            # Age mappings  
            "student_age": ["student_age"],
            
            # Contact mappings
            "contact_email": ["contact_email"],
            
            # Scheduling mappings
            "selected_slot": ["selected_slot"],
            "date_preferences": ["date_preferences"]
        }
        
        if var_name in mappings:
            for data_key in mappings[var_name]:
                if data_key in collected_data and collected_data[data_key]:
                    return collected_data[data_key]
        
        return None
    
    def _generate_dynamic_variables(
        self, 
        generated_vars: Set[str], 
        conversation_state: Dict[str, Any],
        collected_data: Dict[str, Any]
    ) -> Dict[str, str]:
        """Generate dynamic variables like gender, timestamps"""
        
        variables = {}
        
        # Generate gender variables if needed
        gender_vars = {"gender_self_suffix", "gender_pronoun", "gender_article", 
                      "gender_possessive", "gender_child_term"}
        
        if generated_vars & gender_vars:  # If any gender variable is needed
            student_name = collected_data.get("child_name")
            gender_variables = gender_detector.get_template_variables(
                conversation_state, student_name
            )
            
            # Only include requested gender variables
            for var_name in generated_vars & gender_vars:
                if var_name in gender_variables:
                    variables[var_name] = gender_variables[var_name]
        
        # Add other dynamic variables as needed
        # TODO: Add timestamp, formatting, etc.
        
        return variables


# Global instance
template_variable_resolver = TemplateVariableResolver()