from typing import Dict, Any
from ..state.models import CeciliaState, ConversationStage, ConversationStep
from ..state.managers import StateManager
from ..state.models import safe_update_state
import logging

logger = logging.getLogger(__name__)

class GreetingNode:
    """
    Node de saudação - NOVA ARQUITETURA PHASE 2
    
    - Se planned_response existe: Usa resposta pronta e aplica business updates
    - Se enhance_with_llm: Coleta contexto para geração LLM
    """
    
    def __init__(self):
        pass
    
    async def __call__(self, state: CeciliaState) -> Dict[str, Any]:
        """
        Processa estágio de saudação - NOVA ARQUITETURA
        
        Se planned_response existe: Usa resposta pronta e aplica business updates
        Se enhance_with_llm: Executa lógica completa para coletar dados/contexto
        """
        logger.info(f"Processing greeting for {state['phone_number']} - step: {state['current_step']}")
        
        # PHASE 2 ARCHITECTURE: Check if response is pre-planned
        if state.get("planned_response"):
            response = state["planned_response"]
            # Clear planned_response to avoid reuse
            del state["planned_response"]
            
            # Apply business logic updates only (no response generation)
            updates = self._get_business_updates_for_greeting(state)
            
            logger.info(f"✅ Using pre-planned response (threshold_action != enhance_with_llm)")
            return self._create_response(state, response, updates)
        
        # ENHANCE_WITH_LLM PATH: Execute full logic to gather data
        routing_decision = state.get("routing_decision", {})
        if routing_decision.get("threshold_action") != "enhance_with_llm":
            logger.warning(f"⚠️ No planned_response but threshold_action is {routing_decision.get('threshold_action')}")
            # This shouldn't happen - ResponsePlanner should have generated response
            response = "Olá! Sou Cecília do Kumon Vila A. Como posso ajudá-lo hoje?"
            updates = self._get_business_updates_for_greeting(state)
            return self._create_response(state, response, updates)
        
        logger.info(f"🤖 Executing full greeting logic for LLM enhancement")
        
        # ENHANCE_WITH_LLM: Collect data and context for LLM generation
        # The actual response will be generated by ResponsePlanner after this node
        user_message = state["last_user_message"]
        current_step = state["current_step"]
        
        # Collect relevant context for LLM
        state["llm_context"] = {
            "stage": "greeting",
            "step": current_step.value if current_step else "welcome",
            "user_message": user_message,
            "collected_data": state.get("collected_data", {}),
            "conversation_history": state.get("conversation_history", [])
        }
        
        # Apply business updates based on current step
        updates = self._get_business_updates_for_greeting(state)
        
        # ResponsePlanner will generate the actual response after this
        logger.info(f"✅ Context collected for LLM generation")
        return {
            "updated_state": StateManager.update_state(state, updates),
            "response": "",  # Response will be generated by ResponsePlanner
            "stage": state["current_stage"],
            "step": state["current_step"],
            "intent": "greeting"
        }
    
    def _create_response(
        self, 
        state: CeciliaState, 
        response: str, 
        updates: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Cria resposta padronizada do node"""
        # Atualizar estado
        updated_state = StateManager.update_state(state, updates)
        
        return {
            "response": response,
            "updated_state": updated_state,
            "stage": updated_state["current_stage"],
            "step": updated_state["current_step"],
            "intent": "greeting_flow"
        }
    
    def _get_business_updates_for_greeting(self, state: CeciliaState) -> Dict[str, Any]:
        """
        Aplica apenas updates de negócio baseado no step atual do greeting.
        Não gera resposta - apenas atualiza collected_data, stage/step, métricas.
        """
        current_step = state.get("current_step")
        user_message = state.get("last_user_message", "")
        
        if current_step == ConversationStep.WELCOME:
            return {"current_step": ConversationStep.PARENT_NAME_COLLECTION}
        
        elif current_step == ConversationStep.PARENT_NAME_COLLECTION:
            parent_name = user_message.strip()
            return {
                "parent_name": parent_name,
                "current_step": ConversationStep.INITIAL_RESPONSE
            }
        
        elif current_step == ConversationStep.INITIAL_RESPONSE:
            user_message_lower = user_message.lower()
            
            if any(word in user_message_lower for word in [
                "filho", "filha", "criança", "filho(a)", "outra pessoa", "outra"
            ]):
                return {
                    "is_for_self": False,
                    "relationship": "responsável por filho(a)",
                    "current_step": ConversationStep.CHILD_NAME_COLLECTION,
                    "data": {**state.get("data", {}), "is_for_self": False}
                }
            
            elif any(word in user_message_lower for word in [
                "eu", "mim", "mesmo", "mesma", "para mim"
            ]):
                parent_name = state.get("parent_name", "")
                return {
                    "is_for_self": True,
                    "child_name": parent_name,
                    "current_stage": ConversationStage.QUALIFICATION,
                    "current_step": ConversationStep.CHILD_AGE_INQUIRY
                }
            
            else:
                return {"failed_attempts": 1}
        
        elif current_step == ConversationStep.CHILD_NAME_COLLECTION:
            child_name = user_message.strip().title()
            return {
                "child_name": child_name,
                "current_stage": ConversationStage.QUALIFICATION,
                "current_step": ConversationStep.CHILD_AGE_INQUIRY,
                "data": {**state.get("data", {}), "child_name": child_name}
            }
        
        return {}

# Função para uso no LangGraph
async def greeting_node(state: CeciliaState) -> CeciliaState:
    """Entry point para LangGraph"""
    node = GreetingNode()
    result = await node(state)
    
    # Atualizar estado com resposta
    # CRITICAL FIX: Use safe_update_state to preserve CeciliaState structure
    safe_update_state(state, result["updated_state"])
    state["last_bot_response"] = result["response"]
    
    return state