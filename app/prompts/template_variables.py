"""
Template Variable System with Stage-Aware Data Collection

Intelligent variable resolution system that:
- Maps conversation stages to required data
- Collects data from CeciliaState.collected_data
- Applies intelligent fallbacks for missing data
- Integrates gender detection when appropriate
"""

from typing import Dict, Any, Optional, Set, List
from enum import Enum

from ..core.state.models import ConversationStage, ConversationStep
from ..utils.gender_detector import gender_detector
from ..core.logger import app_logger


class VariableType(Enum):
    """Types of template variables"""
    REQUIRED = "required"        # Must be available, use fallback if missing
    OPTIONAL = "optional"        # Use if available, skip if missing
    GENERATED = "generated"      # Generated by system (gender, timestamps)
    FORBIDDEN = "forbidden"      # Not allowed at this stage


class VariablePolicy:
    """Policy for variable resolution at specific stages"""
    
    def __init__(self, required: List[str] = None, optional: List[str] = None, 
                 forbidden: List[str] = None):
        self.required = set(required or [])
        self.optional = set(optional or [])
        self.forbidden = set(forbidden or [])


class StageDataMapper:
    """Maps conversation stages to expected data and variables"""
    
    def __init__(self):
        # Variable resolution policies by stage:step
        self.variable_policies = {
            # GREETING stage - no gender assumptions allowed
            "GREETING:WELCOME": VariablePolicy(
                required=[],  # Nothing required at initial greeting
                optional=["parent_name"],  # Use parent_name if available (from previous interaction)
                forbidden=["gender_pronoun", "gender_self_suffix", "gender_article", 
                          "gender_possessive", "gender_child_term", "child_name", "student_name"]
            ),
            "GREETING:ASK_PURPOSE": VariablePolicy(
                required=[],
                optional=["parent_name"],
                forbidden=["gender_pronoun", "gender_self_suffix", "gender_article",
                          "gender_possessive", "gender_child_term"]
            ),
            
            # QUALIFICATION stage - start collecting names
            "QUALIFICATION:DATA_COLLECTION": VariablePolicy(
                required=["parent_name"],  # Now we need parent name
                optional=["child_name", "student_name"],
                forbidden=["gender_self_suffix"]  # Still avoid gender assumptions
            ),
            "QUALIFICATION:CONFIRM_DATA": VariablePolicy(
                required=["parent_name", "child_name"],
                optional=["student_age", "preferred_pronoun"],
                forbidden=[]  # Can use gender if explicitly provided
            ),
            
            # Default policy for unmapped stages
            "DEFAULT": VariablePolicy(
                required=[],
                optional=["parent_name", "child_name", "student_name"],
                forbidden=[]
            )
        }
        
        # Define what data is expected at each stage
        self.stage_data_mapping = {
            ConversationStage.GREETING: {
                "available_data": ["parent_name", "child_name", "is_for_self"],
                "required_variables": set(),  # GREETING has no required variables - simple welcome
                "optional_variables": {"username", "child_name", "student_name"},
                "generated_variables": {"gender_self_suffix", "gender_pronoun"}
            },
            
            ConversationStage.QUALIFICATION: {
                "available_data": ["parent_name", "child_name", "is_for_self", "student_age", "education_level"],
                "required_variables": {"username", "child_name", "student_name"},
                "optional_variables": {"student_age", "education_level"},
                "generated_variables": {"gender_pronoun", "gender_article", "gender_child_term"}
            },
            
            ConversationStage.INFORMATION_GATHERING: {
                "available_data": ["parent_name", "child_name", "student_age", "programs_of_interest"],
                "required_variables": {"username", "student_name"},
                "optional_variables": {"student_age", "programs_of_interest"},
                "generated_variables": {"gender_pronoun", "gender_possessive"}
            },
            
            ConversationStage.SCHEDULING: {
                "available_data": ["parent_name", "child_name", "date_preferences", "available_slots", "selected_slot"],
                "required_variables": {"username", "student_name"},
                "optional_variables": {"selected_slot", "date_preferences"},
                "generated_variables": {"gender_pronoun"}
            },
            
            ConversationStage.CONFIRMATION: {
                "available_data": ["parent_name", "child_name", "selected_slot", "contact_email"],
                "required_variables": {"username", "student_name", "contact_email"},
                "optional_variables": {"selected_slot"},
                "generated_variables": {"gender_pronoun"}
            }
        }
        
        # Fallback values for missing required data
        self.fallbacks = {
            "username": "responsável", 
            "child_name": "seu(a) filho(a)",
            "student_name": "seu(a) filho(a)",
            "student_age": "criança",
            "contact_email": "seu email"
        }


class TemplateVariableResolver:
    """Resolves template variables intelligently based on conversation state"""
    
    def __init__(self):
        self.mapper = StageDataMapper()
        self.policy_enforcement_enabled = True  # Can be disabled for testing
    
    def get_template_variables(
        self,
        conversation_state: Dict[str, Any],
        user_variables: Optional[Dict[str, Any]] = None,
        stage_override: Optional[ConversationStage] = None,
        step_override: Optional[ConversationStep] = None
    ) -> Dict[str, str]:
        """
        Get all template variables for current conversation state
        
        Args:
            conversation_state: Current CeciliaState
            user_variables: Additional variables provided by caller
            stage_override: Override stage detection (for testing)
            
        Returns:
            Complete variable dictionary ready for template formatting
        """
        try:
            # Determine current stage and step
            current_stage = stage_override or conversation_state.get("current_stage", ConversationStage.GREETING)
            current_step = step_override or conversation_state.get("current_step", "WELCOME")
            collected_data = conversation_state.get("collected_data", {})
            
            # Get policy for current stage:step
            policy = self._get_variable_policy(current_stage, current_step)
            
            app_logger.info(f"Resolving variables for stage: {current_stage}, step: {current_step}")
            if self.policy_enforcement_enabled:
                app_logger.debug(f"Policy - required: {policy.required}, forbidden: {policy.forbidden}")
            
            # Get stage mapping (fallback for legacy compatibility)
            stage_config = self.mapper.stage_data_mapping.get(current_stage, {})
            
            # Use policy if enforcement is enabled, otherwise fall back to stage config
            if self.policy_enforcement_enabled:
                required_vars = policy.required
                optional_vars = policy.optional
                # Filter out forbidden variables from generated vars
                stage_generated = stage_config.get("generated_variables", set())
                generated_vars = stage_generated - policy.forbidden
                
                if stage_generated & policy.forbidden:
                    app_logger.info(f"Blocked forbidden variables: {stage_generated & policy.forbidden}")
            else:
                required_vars = stage_config.get("required_variables", set())
                optional_vars = stage_config.get("optional_variables", set())
                generated_vars = stage_config.get("generated_variables", set())
            
            variables = {}
            
            # 1. Process required variables with intelligent fallbacks
            for var_name in required_vars:
                variables[var_name] = self._resolve_required_variable(
                    var_name, collected_data, user_variables, current_stage
                )
            
            # 2. Process optional variables (only if available)
            for var_name in optional_vars:
                value = self._resolve_optional_variable(
                    var_name, collected_data, user_variables
                )
                if value is not None:
                    variables[var_name] = value
            
            # 3. Generate dynamic variables (gender, timestamps, etc.)
            generated = self._generate_dynamic_variables(
                generated_vars, conversation_state, collected_data, policy
            )
            variables.update(generated)
            
            # 4. Add user-provided variables (override everything)
            if user_variables:
                variables.update(user_variables)
            
            app_logger.info(f"Resolved {len(variables)} variables: {list(variables.keys())}")
            
            # Log policy enforcement details
            if self.policy_enforcement_enabled and policy.forbidden:
                missing_required = policy.required - set(variables.keys())
                if missing_required:
                    app_logger.warning(f"Missing required variables: {missing_required}")
            
            return variables
            
        except Exception as e:
            app_logger.error(f"Error resolving template variables: {e}")
            return user_variables or {}
    
    def _resolve_required_variable(
        self, 
        var_name: str, 
        collected_data: Dict[str, Any], 
        user_variables: Optional[Dict[str, Any]],
        current_stage: Optional[ConversationStage] = None
    ) -> str:
        """Resolve required variable with intelligent fallback"""
        
        # Priority 1: User-provided variables
        if user_variables and var_name in user_variables:
            return str(user_variables[var_name])
        
        # Priority 2: Collected data with exact match
        if var_name in collected_data:
            value = collected_data[var_name]
            if value:
                return str(value)
        
        # Priority 3: Smart mapping from collected data
        value = self._smart_data_mapping(var_name, collected_data)
        if value:
            return str(value)
        
        # Priority 4: Intelligent fallback
        fallback = self.mapper.fallbacks.get(var_name, f"[{var_name}]")
        
        # Don't warn for GREETING stage - it's expected to use defaults
        if current_stage == ConversationStage.GREETING:
            app_logger.debug(f"Using default for GREETING variable '{var_name}': {fallback}")
        else:
            app_logger.warning(f"Using fallback for required variable '{var_name}': {fallback}")
        return fallback
    
    def _resolve_optional_variable(
        self, 
        var_name: str, 
        collected_data: Dict[str, Any], 
        user_variables: Optional[Dict[str, Any]]
    ) -> Optional[str]:
        """Resolve optional variable, return None if not available"""
        
        # Priority 1: User-provided variables
        if user_variables and var_name in user_variables:
            return str(user_variables[var_name])
        
        # Priority 2: Direct mapping from collected data
        if var_name in collected_data:
            value = collected_data[var_name]
            if value:
                return str(value)
        
        # Priority 3: Smart mapping
        value = self._smart_data_mapping(var_name, collected_data)
        if value:
            return str(value)
        
        # Return None for missing optional variables
        return None
    
    def _smart_data_mapping(self, var_name: str, collected_data: Dict[str, Any]) -> Optional[str]:
        """Intelligent mapping between variable names and collected data"""
        
        mappings = {
            # Name mappings
            "username": ["parent_name", "child_name"],
            "student_name": ["child_name", "parent_name"],
            "child_name": ["child_name"],
            
            # Age mappings  
            "student_age": ["student_age"],
            
            # Contact mappings
            "contact_email": ["contact_email"],
            
            # Scheduling mappings
            "selected_slot": ["selected_slot"],
            "date_preferences": ["date_preferences"]
        }
        
        if var_name in mappings:
            for data_key in mappings[var_name]:
                if data_key in collected_data and collected_data[data_key]:
                    return collected_data[data_key]
        
        return None
    
    def _generate_dynamic_variables(
        self, 
        generated_vars: Set[str], 
        conversation_state: Dict[str, Any],
        collected_data: Dict[str, Any],
        policy: Optional['VariablePolicy'] = None
    ) -> Dict[str, str]:
        """Generate dynamic variables like gender, timestamps"""
        
        variables = {}
        
        # Generate gender variables if needed
        gender_vars = {"gender_self_suffix", "gender_pronoun", "gender_article", 
                      "gender_possessive", "gender_child_term"}
        
        # Check if we should generate gender variables
        allowed_gender_vars = generated_vars & gender_vars
        
        # Apply policy restrictions if enforcement is enabled
        if self.policy_enforcement_enabled and policy:
            allowed_gender_vars = allowed_gender_vars - policy.forbidden
            if generated_vars & gender_vars & policy.forbidden:
                app_logger.debug(
                    f"Skipping forbidden gender variables: {generated_vars & gender_vars & policy.forbidden}"
                )
        
        if allowed_gender_vars:  # If any gender variable is allowed and needed
            # Check if we have sufficient data for gender detection
            student_name = collected_data.get("child_name")
            preferred_pronoun = collected_data.get("preferred_pronoun")
            
            # Only attempt gender detection if we have actual data
            if student_name or preferred_pronoun:
                gender_variables = gender_detector.get_template_variables(
                    conversation_state, student_name
                )
                
                # Only include allowed gender variables
                for var_name in allowed_gender_vars:
                    if var_name in gender_variables:
                        variables[var_name] = gender_variables[var_name]
                        app_logger.debug(f"Generated gender variable: {var_name}={gender_variables[var_name]}")
            else:
                app_logger.debug(
                    f"Insufficient data for gender detection (no child_name or preferred_pronoun). "
                    f"Skipping: {allowed_gender_vars}"
                )
        
        # Add other dynamic variables as needed
        # TODO: Add timestamp, formatting, etc.
        
        return variables
    
    def _get_variable_policy(
        self, 
        stage: ConversationStage, 
        step: Optional[str] = None
    ) -> VariablePolicy:
        """Get variable policy for current stage and step"""
        
        # Build policy key
        if step:
            # Convert step to string if it's an enum
            step_str = step.value if hasattr(step, 'value') else str(step)
            policy_key = f"{stage.value}:{step_str}"
        else:
            policy_key = stage.value
        
        # Try exact match first
        if policy_key in self.mapper.variable_policies:
            return self.mapper.variable_policies[policy_key]
        
        # Try stage-only match
        stage_key = stage.value
        for key in self.mapper.variable_policies:
            if key.startswith(f"{stage_key}:"):
                return self.mapper.variable_policies[key]
        
        # Return default policy
        return self.mapper.variable_policies.get("DEFAULT", VariablePolicy())


# Global instance
template_variable_resolver = TemplateVariableResolver()